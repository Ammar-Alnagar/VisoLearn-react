import * as React from "react";
import type { MetaFunction, LoaderFunctionArgs } from "@remix-run/node";
import { json } from "@remix-run/node";
import {
  Form, // Keep Remix Form for the initial setup form
  useLoaderData,
  useFetcher,
  useSubmit,
  useNavigation,
} from "@remix-run/react";
// Assuming static fallback exists if needed, but primary focus is dynamic generation
// import { getImageByDifficulty, type ImageData } from "~/data/images.server";
import {
  generateImageFeatures,
  generateImage,
  type ChatEntry as ApiChatEntry, // Rename to avoid conflict with local history type
} from "~/utils/gemini.server.ts";
import type { ShouldRevalidateFunction } from "@remix-run/react";

// Define ImageData locally if not importing from images.server
// Ensure this matches the structure used/returned by generateImage/generateImageFeatures
export interface ImageData {
  id: string;
  url: string;
  alt: string;
  features: string[];
  difficulty: "easy" | "medium" | "hard";
}

export const meta: MetaFunction = () => {
  return [
    { title: "VisoLearn React Version" },
    { name: "description", content: "Describe images with hints from Gemini!" },
  ];
};

// --- Local Storage Keys ---
const STORAGE_KEY_GAME_STATE = "geminiImageDescriberGameState";

// Local chat history structure (simpler for display)
interface DisplayChatEntry {
  role: "user" | "model";
  text: string; // Includes prefix like "User: " or "Gemini: "
}

// --- Game State Interface ---
interface GameState {
  image: ImageData | null; // ImageData includes id, url, alt, features[], difficulty
  chatHistory: DisplayChatEntry[]; // Use the display-focused type here
  correctFeatures: string[];
  gameTrulyFinished: boolean;
  thresholdMet: boolean;
  allFeaturesFound: boolean;
  gameStarted: boolean;
  attemptsRemaining: number;
  maxAttempts: number;
  winThreshold: number;
  userInput: {
    // Store the settings used to start *this* game
    age: string;
    level: string; // difficulty
    style: string;
    topic: string;
    attempts: string;
    threshold: string;
  } | null;
}

interface LoaderData {
  // Data ONLY provided when a NEW game is successfully generated by the loader
  newGameData?: {
    image: ImageData; // Contains the newly generated image/features
    maxAttempts: number;
    winThreshold: number;
    userInput: GameState["userInput"]; // The input that generated this game
  };
  // Basic settings derived from URL, always present unless error
  initialStateData: {
    // Ensure this is always present
    maxAttempts: number;
    winThreshold: number;
  };
  // Flag indicating if the URL *suggests* an active game (has imageId)
  loaderIndicatesActiveGame: boolean;
  error?: string; // Error during loader execution (e.g., image gen failure)
}

// --- ActionData Interface (for fetcher response from /api/chat) ---
// Matches the structure returned by the /api/chat action
interface ActionData {
  message?: string;
  error?: string;
  gameTrulyFinished?: boolean;
  allFeaturesFound?: boolean;
  correctFeatures?: string[];
  attemptsRemaining?: number;
  updatedChatHistory?: ApiChatEntry[]; // Optional: If API returns full history
}

// --- Loader ---
// Point 1: Modify the loader to be more strict
export const loader = async ({
  request,
}: LoaderFunctionArgs): Promise<LoaderData> => {
  const timestamp = new Date().toISOString();
  console.log(`\n--- LOADER EXECUTING (${timestamp}) ---`);
  const url = new URL(request.url);
  const searchParams = url.searchParams;
  console.log(`>>> LOADER PARAMS: ${searchParams.toString()}`);

  // Parse base settings from URL (always needed)
  const attemptsStr = searchParams.get("attempts") || "10";
  const thresholdStr = searchParams.get("threshold") || "4";
  let attempts = parseInt(attemptsStr, 10);
  if (isNaN(attempts) || attempts < 1) attempts = 10;
  let threshold = parseInt(thresholdStr, 10);
  if (isNaN(threshold) || threshold < 1) threshold = 4;

  const initialStateData = { maxAttempts: attempts, winThreshold: threshold };

  // Check if this is explicitly a request to start a NEW game
  const isExplicitNewGame = searchParams.get("startNewGame") === "true";
  console.log(
    `Loader (${timestamp}): Is this an explicit new game request? ${isExplicitNewGame}`
  );

  // Only proceed with image generation if it's an explicit new game request
  if (isExplicitNewGame) {
    console.log(`>>> !!! LOADER triggered NEW GAME GENERATION (Explicit) !!!`);
    const difficultyParam = searchParams.get("difficulty");
    const difficulty =
      difficultyParam === "easy" ||
      difficultyParam === "medium" ||
      difficultyParam === "hard"
        ? difficultyParam
        : null;
    const topic = searchParams.get("topic");
    const age = searchParams.get("age") || "";
    const style = searchParams.get("style") || "any";

    if (difficulty && topic) {
      console.log(
        `Loader (${timestamp}): New game params valid (difficulty=${difficulty}, topic=${topic}). Generating image...`
      );
      const imageGenPrompt = `Generate an image suitable for a ${difficulty} description game. User age: ${
        age || "unspecified"
      }. Style: ${style}. Topic: ${topic}. Ensure distinct, describable features.`;

      let generatedImageData: ImageData | null = null;
      let errorMsg: string | undefined = undefined;

      try {
        const dynamicImageResult = await generateImage(imageGenPrompt);

        if (dynamicImageResult?.url && dynamicImageResult?.alt) {
          console.log(
            `Loader (${timestamp}): Image generated successfully (Data URL). Generating features...`
          );
          const generatedFeatures = await generateImageFeatures(
            dynamicImageResult.alt
          );
          // Ensure at least 3 features, use defaults if fewer
          const features =
            generatedFeatures.length >= 3
              ? generatedFeatures
              : ["object", "color", "action", "setting"];
          console.log(`Loader (${timestamp}): Features generated:`, features);

          generatedImageData = {
            id: `gen-${Date.now()}`,
            url: dynamicImageResult.url,
            alt: dynamicImageResult.alt,
            features: features,
            difficulty: difficulty,
          };
          console.log(
            "Loader: Dynamically generated image data:",
            generatedImageData
          );
        } else {
          console.warn(
            "Loader: Gemini image generation returned null or incomplete data."
          );
          errorMsg =
            "Failed to generate image from Gemini. Please try different parameters.";
        }
      } catch (error: any) {
        console.error("Loader: Error during image/feature generation:", error);
        errorMsg = `Error generating image or features: ${
          error.message || "Unknown error"
        }. Please try again.`;
      }

      if (!generatedImageData) {
        console.error(
          "Loader: Failed to create generatedImageData. Returning error."
        );
        // Return error *with* initialStateData so UI can still render base elements
        return {
          error:
            errorMsg ??
            "Could not generate image for the specified parameters.",
          loaderIndicatesActiveGame: false, // Failed to start, so no active game
          initialStateData: initialStateData,
        };
      }

      console.log("Loader: Returning NEW game data.");
      const currentUserInput: GameState["userInput"] = {
        age,
        level: difficulty,
        style,
        topic,
        attempts: String(attempts),
        threshold: String(threshold),
      };

      return {
        newGameData: {
          image: generatedImageData,
          maxAttempts: attempts,
          winThreshold: threshold,
          userInput: currentUserInput,
        },
        loaderIndicatesActiveGame: true, // New game successfully created
        initialStateData: initialStateData,
        error: errorMsg, // Pass along non-fatal errors if any
      };
    } else {
      // Explicit new game request but missing parameters
      console.warn(
        `Loader (${timestamp}): Explicit new game request, but missing difficulty or topic.`
      );
      return {
        error:
          "Missing required parameters (difficulty, topic) to start a new game.",
        loaderIndicatesActiveGame: false,
        initialStateData: initialStateData,
      };
    }
  } else {
    // Not an explicit new game request, just return basic data
    const imageId = searchParams.get("imageId");
    const loaderIndicatesActiveGame = !!imageId;
    console.log(
      `Loader (${timestamp}): Not an explicit new game request. Active game indicated by URL (imageId=${imageId})? ${loaderIndicatesActiveGame}`
    );
    return {
      loaderIndicatesActiveGame: loaderIndicatesActiveGame,
      initialStateData: initialStateData,
      // No newGameData here
      // No error here unless something fundamental failed earlier
    };
  }
};

// Point 4: Add explicit reload control
export const shouldRevalidate: ShouldRevalidateFunction = ({
  actionResult, // result of fetcher/action
  currentParams,
  currentUrl,
  defaultShouldRevalidate,
  formAction, // action URL submitted to
  formData,
  formEncType,
  formMethod, // 'get', 'post', etc.
  nextParams,
  nextUrl, // the URL we are navigating to
  submission, // Contains info about the submission that triggered the navigation
}) => {
  const nextSearchParams = new URLSearchParams(nextUrl.search);

  // 1. Revalidate if explicitly starting a new game via GET navigation
  if (
    formMethod?.toLowerCase() === "get" && // Check if it's a GET navigation
    nextSearchParams.get("startNewGame") === "true" // Check if the flag is in the *next* URL
  ) {
    console.log(
      "shouldRevalidate: YES - Explicit new game requested via GET navigation."
    );
    return true;
  }

  // 2. Do NOT revalidate after the chat action (POST to /api/chat)
  // This check uses `submission?.action` if available, otherwise falls back to formAction
  const actionTarget = submission?.action ?? formAction;
  if (actionTarget?.endsWith("/api/chat")) {
    console.log("shouldRevalidate: NO - Chat action submission.");
    return false;
  }

  // 3. Fallback to default behavior for other cases (e.g., initial load, manual refresh)
  console.log(
    "shouldRevalidate: Defaulting - Not a new game GET or chat POST."
  );
  return defaultShouldRevalidate;
};

// --- Component ---
export default function Index() {
  const loaderData = useLoaderData<LoaderData>();
  const fetcher = useFetcher<ActionData>();
  const submit = useSubmit();
  const navigation = useNavigation();

  // Check if the *navigation* is submitting the start form (GET)
  const isSubmittingStartForm =
    navigation.state === "loading" && // Use 'loading' for GET navigations
    navigation.location?.search?.includes("startNewGame=true");

  // Check if the *fetcher* is submitting the chat form (POST)
  const isSubmittingChat = fetcher.state !== "idle";

  // --- State Management ---
  const [isClient, setIsClient] = React.useState(false);
  const [gameState, setGameState] = React.useState<GameState>(() => {
    // Initialize with defaults derived *only* from initialStateData
    // loaderData.newGameData will be handled by the effect
    const defaultState: GameState = {
      image: null,
      chatHistory: [],
      correctFeatures: [],
      gameTrulyFinished: false,
      thresholdMet: false,
      allFeaturesFound: false,
      gameStarted: false,
      attemptsRemaining: loaderData.initialStateData.maxAttempts,
      maxAttempts: loaderData.initialStateData.maxAttempts,
      winThreshold: loaderData.initialStateData.winThreshold,
      userInput: null,
    };
    console.log(
      "useState [gameState]: Initializing component state:",
      defaultState
    );
    return defaultState;
  });

  const {
    image,
    chatHistory,
    correctFeatures,
    gameTrulyFinished,
    thresholdMet,
    allFeaturesFound,
    gameStarted,
    attemptsRemaining,
    maxAttempts,
    winThreshold,
    userInput,
  } = gameState;
  const [currentInput, setCurrentInput] = React.useState("");
  const chatContainerRef = React.useRef<HTMLDivElement>(null);

  // --- Effects ---

  // Effect 1: Hydration Check
  React.useEffect(() => {
    setIsClient(true);
    console.log("useEffect [isClient]: Component hydrated.");
  }, []);

  // Effect 2: Initialize/Restore Game State on Client
  // This effect now relies less on loaderIndicatesActiveGame and more on newGameData vs localStorage
  React.useEffect(() => {
    if (!isClient) return;
    console.log(
      "useEffect [isClient, loaderData]: Running game state initialization/restore logic."
    );

    const currentUrl = new URL(window.location.href);
    const urlImageId = currentUrl.searchParams.get("imageId");

    // Scenario 1: Loader provided brand new game data
    if (loaderData.newGameData) {
      console.log(
        "useEffect [isClient, loaderData]: New game data found in loader. Initializing state."
      );
      const {
        image: newImage,
        maxAttempts: newMax,
        winThreshold: newThreshold,
        userInput: newUserInput,
      } = loaderData.newGameData;
      setGameState({
        image: newImage,
        chatHistory: [], // Start fresh
        correctFeatures: [],
        gameTrulyFinished: false,
        thresholdMet: false,
        allFeaturesFound: false,
        gameStarted: true, // Mark as started
        attemptsRemaining: newMax,
        maxAttempts: newMax,
        winThreshold: newThreshold,
        userInput: newUserInput,
      });

      // Update URL to reflect the new game state (imageId, settings)
      // Remove the 'startNewGame' flag from the URL
      const searchParams = new URLSearchParams();
      searchParams.set("imageId", String(newImage.id));
      searchParams.set("attempts", String(newMax));
      searchParams.set("threshold", String(newThreshold));
      if (newUserInput) {
        searchParams.set("topic", newUserInput.topic);
        searchParams.set("difficulty", newUserInput.level);
        searchParams.set("style", newUserInput.style);
        searchParams.set("age", newUserInput.age);
      }
      window.history.replaceState(null, "", `?${searchParams.toString()}`);
      console.log(
        "useEffect [isClient, loaderData]: Cleared localStorage (new game). Updated URL (removed startNewGame)."
      );
      localStorage.removeItem(STORAGE_KEY_GAME_STATE); // Clear any old state
    }
    // Scenario 2: No new game data from loader, attempt restore from localStorage
    else {
      console.log(
        "useEffect [isClient, loaderData]: No new game data in loader. Checking localStorage."
      );
      const savedStateRaw = localStorage.getItem(STORAGE_KEY_GAME_STATE);
      let restoredState: GameState | null = null;

      if (savedStateRaw) {
        try {
          const savedState = JSON.parse(savedStateRaw) as GameState;
          // Check if saved state looks valid and matches the imageId in the URL (if present)
          if (
            savedState.image &&
            savedState.gameStarted &&
            !savedState.gameTrulyFinished &&
            urlImageId && // Only restore if URL indicates an active game
            String(savedState.image.id) === urlImageId
          ) {
            console.log(
              "useEffect [isClient, loaderData]: Valid localStorage state found matching URL imageId. Restoring."
            );
            restoredState = savedState;
            // Restore state, but potentially update maxAttempts/threshold from current URL/loader data
            setGameState({
              ...savedState,
              maxAttempts: loaderData.initialStateData.maxAttempts,
              winThreshold: loaderData.initialStateData.winThreshold,
              // Ensure attemptsRemaining isn't negative or exceeding new max
              attemptsRemaining: Math.min(
                Math.max(savedState.attemptsRemaining, 0),
                loaderData.initialStateData.maxAttempts
              ),
            });
            // Ensure URL reflects the restored game's settings (in case they changed via direct URL edit)
            const searchParams = new URLSearchParams(window.location.search);
            searchParams.set("imageId", String(savedState.image.id));
            searchParams.set(
              "attempts",
              String(loaderData.initialStateData.maxAttempts)
            );
            searchParams.set(
              "threshold",
              String(loaderData.initialStateData.winThreshold)
            );
            if (savedState.userInput) {
              searchParams.set("topic", savedState.userInput.topic);
              searchParams.set("difficulty", savedState.userInput.level);
              searchParams.set("style", savedState.userInput.style);
              searchParams.set("age", savedState.userInput.age);
            }
            window.history.replaceState(
              null,
              "",
              `?${searchParams.toString()}`
            );
          } else {
            console.log(
              "useEffect [isClient, loaderData]: localStorage state invalid, finished, or mismatch with URL imageId. Clearing LS."
            );
            localStorage.removeItem(STORAGE_KEY_GAME_STATE);
          }
        } catch (e) {
          console.error(
            "useEffect [isClient, loaderData]: Failed to parse saved game state:",
            e
          );
          localStorage.removeItem(STORAGE_KEY_GAME_STATE);
        }
      } else {
        console.log(
          "useEffect [isClient, loaderData]: No saved game state found in localStorage."
        );
      }

      // Scenario 3: No new game, no successful restore -> Ensure setup screen state
      if (!restoredState) {
        console.log(
          "useEffect [isClient, loaderData]: No new game and no restore. Ensuring setup screen state."
        );
        // If URL has an imageId but we couldn't restore, the URL is stale. Reset it.
        if (urlImageId) {
          console.log(
            "useEffect [isClient, loaderData]: URL has imageId but no state found/restored. Resetting URL to /"
          );
          window.history.replaceState(null, "", "/");
        }
        // Reset state to show setup screen, using potentially updated defaults from loader
        setGameState({
          image: null,
          chatHistory: [],
          correctFeatures: [],
          gameTrulyFinished: false,
          thresholdMet: false,
          allFeaturesFound: false,
          gameStarted: false,
          attemptsRemaining: loaderData.initialStateData.maxAttempts,
          maxAttempts: loaderData.initialStateData.maxAttempts,
          winThreshold: loaderData.initialStateData.winThreshold,
          userInput: null,
        });
      }
    }
  }, [isClient, loaderData]); // Rerun only when client status or loader data changes

  // Effect 3: Save state to localStorage whenever it changes (if game is active)
  React.useEffect(() => {
    if (isClient && gameStarted && !gameTrulyFinished && image) {
      console.log(
        "useEffect [gameState]: Saving active game state to localStorage",
        { id: image.id, attempts: attemptsRemaining }
      );
      // Create a snapshot of the current game state
      const stateToSave: GameState = { ...gameState };
      localStorage.setItem(STORAGE_KEY_GAME_STATE, JSON.stringify(stateToSave));
    } else if (isClient && (gameTrulyFinished || !gameStarted)) {
      // Clean up localStorage if game ends or hasn't started
      if (localStorage.getItem(STORAGE_KEY_GAME_STATE)) {
        console.log(
          "useEffect [gameState]: Game finished or not started, removing state from localStorage"
        );
        localStorage.removeItem(STORAGE_KEY_GAME_STATE);
      }
    }
    // Dependency: Re-run whenever gameState changes *and* we are on the client
  }, [gameState, isClient]); // Removed redundant dependencies

  // Effect 4: Process fetcher data from /api/chat
  React.useEffect(() => {
    if (fetcher.state === "idle" && fetcher.data) {
      console.log(
        "useEffect [fetcher.data]: Processing fetcher response:",
        fetcher.data
      );
      const {
        message,
        error,
        gameTrulyFinished: finished,
        allFeaturesFound: allFound,
        correctFeatures: newFeatures,
        attemptsRemaining: remaining,
      } = fetcher.data;

      // Check if *any* relevant data field is present in the fetcher response
      if (
        message !== undefined ||
        error !== undefined ||
        finished !== undefined ||
        allFound !== undefined ||
        newFeatures !== undefined ||
        remaining !== undefined
      ) {
        setGameState((prev) => {
          // Add a guard: If the game somehow got reset while fetcher was running, don't apply updates
          if (!prev.gameStarted || !prev.image) {
            console.warn(
              "useEffect [fetcher.data]: Game not started or no image, skipping fetcher state update."
            );
            return prev;
          }
          console.log(
            "useEffect [fetcher.data]: Updating state from fetcher. Prev attempts:",
            prev.attemptsRemaining
          );

          // Prepare new chat history entry from fetcher response
          const newMessageText = message
            ? `Gemini: ${message}`
            : error
            ? `Error: ${error}` // Display API errors in chat
            : null;

          // Avoid adding duplicate messages if fetcher somehow triggers twice rapidly
          const newHistory = [...prev.chatHistory];
          if (newMessageText) {
            const lastMessage = newHistory[newHistory.length - 1];
            if (
              !lastMessage ||
              lastMessage.role !== "model" || // Ensure it's not duplicating the *last* model message
              lastMessage.text !== newMessageText
            ) {
              newHistory.push({ role: "model", text: newMessageText });
            } else {
              console.log(
                "useEffect [fetcher.data]: Skipping duplicate model message."
              );
            }
          }

          // Determine updated game state values, falling back to previous state if data not provided
          const updatedCorrectFeatures = newFeatures ?? prev.correctFeatures;
          const updatedAttemptsRemaining = remaining ?? prev.attemptsRemaining; // Use remaining from API if present
          const updatedTrulyFinished = finished ?? prev.gameTrulyFinished;
          const updatedAllFound = allFound ?? prev.allFeaturesFound;
          // Recalculate thresholdMet based on potentially updated correctFeatures
          const updatedThresholdMet =
            updatedCorrectFeatures.length >= prev.winThreshold;

          // Construct the next state
          const nextState: GameState = {
            ...prev,
            chatHistory: newHistory,
            correctFeatures: updatedCorrectFeatures,
            attemptsRemaining: updatedAttemptsRemaining,
            gameTrulyFinished: updatedTrulyFinished,
            allFeaturesFound: updatedAllFound,
            thresholdMet: updatedThresholdMet,
          };

          console.log(
            "useEffect [fetcher.data]: State updated. Finished:",
            nextState.gameTrulyFinished,
            "AllFound:",
            nextState.allFeaturesFound,
            "ThresholdMet:",
            nextState.thresholdMet,
            "Attempts:",
            nextState.attemptsRemaining
          );
          return nextState;
        });
      } else {
        console.warn(
          "useEffect [fetcher.data]: Received fetcher data, but it contained no relevant fields to update state.",
          fetcher.data
        );
      }
    }
    // Clear fetcher data after processing to prevent reprocessing on unrelated re-renders
    // Note: This might not be strictly necessary depending on Remix/fetcher behavior, but can prevent edge cases.
    // Commented out for now, re-evaluate if needed.
    // if (fetcher.state === 'idle' && fetcher.data) {
    //   fetcher.data = undefined; // Or set specific fields to undefined
    // }
  }, [fetcher.data, fetcher.state]); // Dependencies: only run when fetcher state or data changes

  // Effect 5: Auto-scroll chat
  React.useEffect(() => {
    if (chatContainerRef.current) {
      chatContainerRef.current.scrollTop =
        chatContainerRef.current.scrollHeight;
    }
  }, [chatHistory]); // Dependency: only run when chat history changes

  // --- Event Handlers ---

  // Point 2: Modify handleStartGame to add explicit flag
  const handleStartGame = (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    console.log("handleStartGame: Form submitted.");
    const formData = new FormData(event.currentTarget);

    // Add the explicit new game flag
    formData.append("startNewGame", "true");
    console.log("handleStartGame: Added 'startNewGame=true' to form data.");

    if (isClient) {
      console.log("handleStartGame: Clearing localStorage.");
      localStorage.removeItem(STORAGE_KEY_GAME_STATE);
    }

    // Reset client-side game state *immediately* before navigation starts
    // This ensures the UI reflects the "loading new game" state quicker
    setGameState((prev) => ({
      ...prev,
      image: null,
      chatHistory: [],
      correctFeatures: [],
      gameTrulyFinished: false,
      thresholdMet: false,
      allFeaturesFound: false,
      gameStarted: false, // Mark as not started until loader confirms
      userInput: null, // Clear previous user input settings
      // Update maxAttempts/threshold based on the form being submitted
      attemptsRemaining:
        parseInt(formData.get("attempts") as string, 10) ||
        loaderData.initialStateData.maxAttempts,
      maxAttempts:
        parseInt(formData.get("attempts") as string, 10) ||
        loaderData.initialStateData.maxAttempts,
      winThreshold:
        parseInt(formData.get("threshold") as string, 10) ||
        loaderData.initialStateData.winThreshold,
    }));

    console.log(
      "handleStartGame: Submitting form via GET to trigger loader for new game..."
    );
    submit(formData, {
      method: "get",
      action: "/",
      replace: true, // Use replace to avoid adding the setup screen with params to history
    });
  };

  // Point 3: Ensure chat form prevents route revalidation
  const handleSendMessage = (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    console.log("handleSendMessage: Chat form submitted.");

    const userMessage = currentInput.trim();

    // Validation: Ensure message exists, game is active, not already submitting, etc.
    if (
      !userMessage ||
      !image ||
      !gameStarted ||
      isSubmittingChat ||
      gameTrulyFinished
    ) {
      console.log("handleSendMessage: Submission prevented.", {
        userMessageEmpty: !userMessage,
        imageMissing: !image,
        gameNotStarted: !gameStarted,
        isSubmittingChat,
        gameTrulyFinished,
      });
      return;
    }

    console.log("handleSendMessage: User message:", userMessage);

    // Optimistic UI update: Add user message immediately
    setGameState((prev) => {
      // Guard against race conditions if game ended between input and submit
      if (!prev.gameStarted || prev.gameTrulyFinished) return prev;
      console.log("handleSendMessage: Updating chat history optimistically.");
      return {
        ...prev,
        chatHistory: [
          ...prev.chatHistory,
          { role: "user", text: `User: ${userMessage}` },
        ],
      };
    });
    setCurrentInput(""); // Clear input field

    // Prepare data for the API action
    const formData = new FormData();
    formData.append("userAttempt", userMessage);
    formData.append("imageFeatures", JSON.stringify(image.features || [])); // Send current image features

    // Send current chat history (converting to API format)
    const historyForApi: ApiChatEntry[] = gameState.chatHistory // Use gameState directly here
      .map((entry): ApiChatEntry | null => {
        const text = entry.text.replace(/^(User:|Gemini:|Error:)\s*/, ""); // Strip prefixes
        // Ensure empty model messages (like errors only) aren't sent as empty parts
        if (!text && entry.role === "model") return null;
        return {
          role: entry.role === "user" ? "user" : "model",
          parts: [{ text: text }],
        };
      })
      .filter((entry): entry is ApiChatEntry => entry !== null);

    // Add the *current* user message to the history being sent
    historyForApi.push({ role: "user", parts: [{ text: userMessage }] });

    formData.append("chatHistory", JSON.stringify(historyForApi));
    formData.append(
      "correctFeatures",
      JSON.stringify(gameState.correctFeatures) // Send current correct features
    );
    formData.append("attemptsRemaining", String(gameState.attemptsRemaining)); // Send current attempts
    formData.append("winThreshold", String(gameState.winThreshold)); // Send win threshold

    console.log(
      "handleSendMessage: Submitting fetcher POST to /api/chat (skipping client revalidation)..."
    );
    fetcher.submit(formData, {
      method: "post",
      action: "/api/chat",
      preventScrollReset: true, // Keep scroll position
      unstable_skipClientRevalidation: true, // *** SKIP LOADER RE-RUN ***
    });
    console.log("handleSendMessage: fetcher.submit called.");
  };

  // Point 5: Update handle reset game function
  const handleResetGame = () => {
    console.log("handleResetGame: Resetting game.");
    if (isClient) {
      localStorage.removeItem(STORAGE_KEY_GAME_STATE);
      console.log("handleResetGame: Cleared localStorage.");
    }

    // Reset client-side state immediately
    setGameState((prev) => ({
      ...prev,
      image: null,
      chatHistory: [],
      correctFeatures: [],
      gameTrulyFinished: false,
      thresholdMet: false,
      allFeaturesFound: false,
      gameStarted: false,
      userInput: null,
      // Reset attempts/threshold to initial defaults from the *last* loader run
      attemptsRemaining: loaderData.initialStateData.maxAttempts,
      maxAttempts: loaderData.initialStateData.maxAttempts,
      winThreshold: loaderData.initialStateData.winThreshold,
    }));

    console.log(
      "handleResetGame: Navigating to base URL ('/') via GET to show setup screen..."
    );
    // Navigate to the base path without any search parameters
    // This ensures the loader runs without 'startNewGame' or 'imageId', showing the setup form.
    submit(null, {
      // Using null for formData removes search parameters
      method: "get",
      action: "/",
      replace: true, // Replace history entry
    });
  };

  // --- Render Logic ---

  const showLoadingOverlay = isSubmittingStartForm;
  // Show setup if client is ready, game isn't marked as started *in state*, and loader didn't just provide new game data
  const showSetupScreen = isClient && !gameStarted && !loaderData.newGameData;
  // Show game if game is marked as started *in state* and we have image data
  const showGameScreen = isClient && gameStarted && image;

  let statusMessage = null;
  let statusMessageColor = "";
  if (gameTrulyFinished) {
    if (allFeaturesFound) {
      statusMessage = "Congratulations! You found all the features! ðŸŽ‰";
      statusMessageColor =
        "bg-green-100 dark:bg-green-800 text-green-800 dark:text-green-100";
    } else if (thresholdMet) {
      // If game finished by attempts but threshold was met
      statusMessage = `Game Over! Threshold reached, but you ran out of attempts. Features were: ${
        image?.features?.join(", ") || "N/A"
      }.`;
      statusMessageColor =
        "bg-yellow-100 dark:bg-yellow-800 text-yellow-800 dark:text-yellow-200"; // Yellow because threshold was met
    } else {
      statusMessage = `Game Over! You ran out of attempts. The features were: ${
        image?.features?.join(", ") || "N/A"
      }.`;
      statusMessageColor =
        "bg-red-100 dark:bg-red-800 text-red-800 dark:text-red-100";
    }
  } else if (thresholdMet) {
    statusMessage = `Threshold reached! (${
      correctFeatures.length
    }/${winThreshold}) Keep going to find all ${
      image?.features?.length ?? "?"
    } features.`;
    statusMessageColor =
      "bg-yellow-100 dark:bg-yellow-800 text-yellow-800 dark:text-yellow-200";
  }

  const loaderError = loaderData.error; // Error from the *last* loader run

  return (
    <div className="flex flex-col h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 font-sans relative">
      {/* Loading overlay specifically for new game generation */}
      {showLoadingOverlay && (
        <div className="absolute inset-0 bg-gray-500 bg-opacity-50 dark:bg-gray-800 dark:bg-opacity-60 flex justify-center items-center z-50">
          <div className="text-white text-xl font-semibold animate-pulse p-4 bg-black/50 rounded-lg">
            Generating your game...
          </div>
        </div>
      )}

      <header className="p-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0">
        <h1 className="text-xl sm:text-2xl font-semibold text-center">
          VisoLearn: Image Describer
        </h1>
      </header>

      <main className="flex-1 overflow-hidden p-2 sm:p-4">
        {/* Use state 'gameStarted' primarily to decide rendering */}
        {showSetupScreen && (
          <div className="max-w-lg mx-auto mt-8 bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md">
            {/* Display loader error if it occurred during the last attempt to start a game */}
            {loaderError && (
              <div className="mb-4 p-3 text-red-700 bg-red-100 dark:bg-red-900 dark:text-red-200 rounded border border-red-300 dark:border-red-700">
                <p>
                  <strong>Error starting previous game:</strong> {loaderError}
                </p>
                <p className="text-xs mt-1">
                  Please adjust settings and try again.
                </p>
              </div>
            )}
            <h2 className="text-xl font-semibold mb-5 text-center">
              Start a New Game
            </h2>
            {/* Use Remix Form for GET navigation */}
            <Form
              onSubmit={handleStartGame} // Use our handler to add flag
              method="get" // Method remains GET
              action="/" // Action remains /
              replace // Use replace for history management
              className="space-y-4"
            >
              {/* Topic Input */}
              <div>
                <label
                  htmlFor="topic"
                  className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
                >
                  Topic:
                </label>
                <input
                  type="text"
                  id="topic"
                  name="topic"
                  // Use default values from loader's initial state data if available, fallback to hardcoded
                  defaultValue={
                    loaderData.initialStateData?.userInput?.topic ??
                    "a cute cat"
                  }
                  placeholder="e.g., futuristic city, dog playing fetch"
                  required
                  className="w-full p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>
              {/* Difficulty, Style, Age */}
              <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
                <div>
                  <label
                    htmlFor="difficulty"
                    className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
                  >
                    Difficulty:
                  </label>
                  <select
                    id="difficulty"
                    name="difficulty"
                    defaultValue={
                      loaderData.initialStateData?.userInput?.level ?? "easy"
                    }
                    required
                    className="w-full p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 focus:ring-blue-500 focus:border-blue-500"
                  >
                    <option value="easy">Easy</option>
                    <option value="medium">Medium</option>
                    <option value="hard">Hard</option>
                  </select>
                </div>
                <div>
                  <label
                    htmlFor="style"
                    className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
                  >
                    Style:
                  </label>
                  <input
                    type="text"
                    id="style"
                    name="style"
                    defaultValue={
                      loaderData.initialStateData?.userInput?.style ??
                      "illustration"
                    }
                    placeholder="e.g., cartoon, realistic, abstract"
                    className="w-full p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 focus:ring-blue-500 focus:border-blue-500"
                  />
                </div>
                <div>
                  <label
                    htmlFor="age"
                    className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
                  >
                    Age (Optional):
                  </label>
                  <input
                    type="number"
                    id="age"
                    name="age"
                    defaultValue={
                      loaderData.initialStateData?.userInput?.age ?? ""
                    }
                    min="1"
                    className="w-full p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 focus:ring-blue-500 focus:border-blue-500"
                  />
                </div>
              </div>
              {/* Attempts, Threshold */}
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <div>
                  <label
                    htmlFor="attempts"
                    className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
                  >
                    Attempts:
                  </label>
                  <input
                    type="number"
                    id="attempts"
                    name="attempts"
                    // Default to current settings from initialStateData
                    defaultValue={String(
                      loaderData.initialStateData.maxAttempts
                    )}
                    min="1"
                    max="50"
                    required
                    className="w-full p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 focus:ring-blue-500 focus:border-blue-500"
                  />
                </div>
                <div>
                  <label
                    htmlFor="threshold"
                    className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
                  >
                    Feature Threshold:
                  </label>
                  <input
                    type="number"
                    id="threshold"
                    name="threshold"
                    // Default to current settings from initialStateData
                    defaultValue={String(
                      loaderData.initialStateData.winThreshold
                    )}
                    min="1"
                    max="20"
                    required
                    className="w-full p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 focus:ring-blue-500 focus:border-blue-500"
                  />
                </div>
              </div>
              {/* Submit Button */}
              <button
                type="submit"
                // Disable if a GET navigation for starting a game is in progress
                disabled={isSubmittingStartForm}
                className="w-full bg-blue-600 text-white p-3 rounded-lg font-semibold hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-wait"
              >
                {isSubmittingStartForm ? "Starting..." : "Start Game"}
              </button>
            </Form>
          </div>
        )}

        {/* Show game screen only if gameStarted is true and image exists */}
        {showGameScreen && (
          <div className="flex flex-col lg:flex-row h-full gap-4">
            {/* Image and Info Panel */}
            <div className="w-full lg:w-1/2 xl:w-2/5 flex flex-col bg-white dark:bg-gray-800 p-4 rounded-lg shadow overflow-hidden">
              <h2 className="text-lg font-semibold mb-3 text-center flex-shrink-0">
                Describe this Image:
              </h2>
              <div className="flex-grow flex justify-center items-center min-h-[250px] mb-3 overflow-hidden relative bg-gray-200 dark:bg-gray-700 rounded">
                {image ? (
                  <img
                    key={image.id} // Use image ID as key for transitions on change
                    src={image.url}
                    alt={image.alt || "Generated image"}
                    className={`max-w-full max-h-full object-contain rounded transition-opacity duration-500 ease-in-out opacity-100`}
                  />
                ) : (
                  <div className="text-gray-500 dark:text-gray-400 p-4 text-center">
                    Image loading or missing...
                  </div>
                )}
              </div>
              {/* Game Info Section */}
              <div className="text-xs sm:text-sm text-gray-600 dark:text-gray-400 w-full flex-shrink-0 border-t dark:border-gray-700 pt-3 mt-auto space-y-1">
                <p>
                  <b>Difficulty:</b>{" "}
                  {image?.difficulty ?? userInput?.level ?? "N/A"}
                </p>
                <p>
                  <b>Topic:</b> {userInput?.topic || "N/A"}
                </p>
                <p
                  className={`font-medium ${
                    attemptsRemaining <= 3 &&
                    attemptsRemaining > 0 &&
                    !gameTrulyFinished
                      ? "text-orange-500 dark:text-orange-400"
                      : attemptsRemaining <= 0
                      ? "text-red-600 dark:text-red-400"
                      : ""
                  }`}
                >
                  <b>Attempts Remaining:</b> {attemptsRemaining} / {maxAttempts}
                </p>
                <p>
                  <b>Feature Threshold:</b> {winThreshold}
                </p>
                <p
                  className={
                    thresholdMet && !allFeaturesFound && !gameTrulyFinished
                      ? "font-semibold text-yellow-600 dark:text-yellow-400"
                      : allFeaturesFound
                      ? "font-semibold text-green-600 dark:text-green-400"
                      : ""
                  }
                >
                  <b>Features Found:</b> {correctFeatures.length} /{" "}
                  {image?.features?.length ?? "?"}
                  {thresholdMet &&
                    !allFeaturesFound &&
                    !gameTrulyFinished &&
                    " (Threshold Met!)"}
                  {allFeaturesFound && " (All Found!)"}
                </p>
                {/* Feature List (Hidden/Revealed) */}
                {image?.features && image.features.length > 0 ? (
                  <ul className="list-disc pl-5 text-xs max-h-24 overflow-y-auto">
                    {image.features.map((feature) => {
                      const lowerFeature = feature.toLowerCase();
                      const found = correctFeatures.some(
                        (cf) => cf.toLowerCase() === lowerFeature
                      );
                      return (
                        <li
                          key={feature}
                          className={`transition-colors ${
                            found
                              ? "text-green-600 dark:text-green-400 line-through"
                              : "text-gray-500 dark:text-gray-400"
                          }`}
                        >
                          {found ? feature : "???"}{" "}
                          {/* Show feature if found */}
                        </li>
                      );
                    })}
                  </ul>
                ) : (
                  <p className="text-xs text-gray-400 italic">
                    No features defined for this image.
                  </p>
                )}
                {/* Display loader error persistently if it happened but game screen is shown */}
                {loaderError && !showSetupScreen && (
                  <p className="text-xs text-yellow-600 dark:text-yellow-400 mt-1">
                    Note: There was an issue generating this game ({loaderError}
                    )
                  </p>
                )}
              </div>
              {/* Reset Game Button */}
              <button
                onClick={handleResetGame}
                // Disable if starting a new game or submitting chat
                disabled={isSubmittingStartForm || isSubmittingChat}
                className="mt-4 w-full bg-gray-500 text-white p-2 rounded-lg hover:bg-gray-600 transition-colors text-sm flex-shrink-0 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                New Game / Change Settings
              </button>
            </div>

            {/* Chat Panel */}
            <div className="w-full lg:w-1/2 xl:w-3/5 flex flex-col bg-white dark:bg-gray-800 p-4 rounded-lg shadow">
              <h2 className="text-lg font-semibold mb-3 flex-shrink-0">
                Chat with Gemini
              </h2>
              {/* Chat History */}
              <div
                ref={chatContainerRef}
                className="flex-1 overflow-y-auto mb-4 p-3 space-y-3 bg-gray-50 dark:bg-gray-700 rounded-md border border-gray-200 dark:border-gray-600 min-h-[200px]"
              >
                {/* Initial Gemini Prompt */}
                <div className="flex justify-start">
                  <div className="p-2.5 rounded-lg bg-gray-200 text-gray-800 dark:bg-gray-600 dark:text-gray-100 text-sm shadow-sm w-fit">
                    Gemini: Describe a feature you see in the image!
                  </div>
                </div>
                {/* Rendered Chat History */}
                {chatHistory.map((msg, index) => (
                  <div
                    key={index}
                    className={`flex ${
                      msg.role === "user" ? "justify-end" : "justify-start"
                    }`}
                  >
                    <div
                      className={`p-2.5 rounded-lg max-w-[85%] w-fit text-sm shadow-sm break-words ${
                        msg.role === "user"
                          ? "bg-blue-500 text-white dark:bg-blue-600"
                          : msg.text.startsWith("Error:") // Style API errors differently
                          ? "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200"
                          : "bg-gray-200 text-gray-800 dark:bg-gray-600 dark:text-gray-100"
                      }`}
                    >
                      {/* Render newlines correctly */}
                      {msg.text.split("\n").map((line, i) => (
                        <p key={i}>{line || "\u00A0"}</p> // Use non-breaking space for empty lines
                      ))}
                    </div>
                  </div>
                ))}
                {/* Thinking Indicator */}
                {isSubmittingChat && (
                  <div className="flex justify-start">
                    <div className="p-2.5 rounded-lg bg-gray-200 dark:bg-gray-600 text-gray-600 dark:text-gray-400 text-sm italic w-fit shadow-sm animate-pulse">
                      Gemini is thinking...
                    </div>
                  </div>
                )}
                {/* Status Message Area */}
                {statusMessage && (
                  <div
                    className={`p-3 rounded-lg ${statusMessageColor} text-center text-sm font-semibold w-full mt-2 shadow`}
                  >
                    {statusMessage}{" "}
                    {gameTrulyFinished && 'Click "New Game" to play again.'}
                  </div>
                )}
              </div>
              {/* Chat Input Form (using standard form, handled by handleSendMessage) */}
              <form
                onSubmit={handleSendMessage}
                // No method/action needed here as fetcher handles it
                className="mt-auto flex-shrink-0"
              >
                <div className="flex items-center gap-2 border border-gray-300 dark:border-gray-600 rounded-lg p-2 focus-within:ring-2 focus-within:ring-blue-500">
                  <input
                    type="text"
                    value={currentInput}
                    onChange={(e) => setCurrentInput(e.target.value)}
                    placeholder={
                      gameTrulyFinished
                        ? "Game finished! Start a new game."
                        : "Describe a feature..."
                    }
                    className="flex-1 p-2 border-none focus:ring-0 bg-transparent dark:text-gray-100 placeholder-gray-500 dark:placeholder-gray-400"
                    // Disable if chat is submitting, game finished, or new game loading
                    disabled={
                      isSubmittingChat ||
                      gameTrulyFinished ||
                      isSubmittingStartForm
                    }
                    autoComplete="off"
                    aria-label="Chat input"
                  />
                  <button
                    type="submit"
                    className="bg-blue-600 text-white p-2 rounded-md hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 dark:focus:ring-offset-gray-800"
                    // Disable if chat is submitting, game finished, input empty, or new game loading
                    disabled={
                      isSubmittingChat ||
                      gameTrulyFinished ||
                      !currentInput.trim() ||
                      isSubmittingStartForm
                    }
                    aria-label="Send message"
                  >
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      viewBox="0 0 20 20"
                      fill="currentColor"
                      className="w-5 h-5"
                    >
                      <path d="M3.105 3.105a1.5 1.5 0 012.122-.001L19.43 14.29a1.5 1.5 0 01-1.13 2.576H1.5a1.5 0 01-1.49-1.813L3.105 3.105zM4.879 6.121L1.5 15.43h14.805L4.879 6.12z" />
                    </svg>
                  </button>
                </div>
                {/* Display Fetcher Error (e.g., API communication failed) */}
                {fetcher.data?.error && (
                  <p className="text-xs text-red-500 dark:text-red-400 mt-1 text-center">
                    Chat Error: {fetcher.data.error}
                  </p>
                )}
              </form>
            </div>
          </div>
        )}
      </main>
    </div>
  );
}
